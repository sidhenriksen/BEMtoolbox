% Class for creating model binocular cells
% Author: Sid Henriksen
% Laboratory of Sensorimotor Research - National Institutes of Health (US)
% Institute of Neuroscience - Newcastle University (UK)
% Email: sid.henriksen@gmail.com
% 
% Please email me with any bugs or suggestions.
%
% All code released under GNU GPL v2
classdef BEMunit
    properties
        
        % spatial dimensions; valid is 1d and 2d
        dim='2d';
        
        x0;
        y0;
        
        % binocular properties
        dx=0; %horizontal disparity
        dy=0; %vertical disparity
        dphi=0; %phase disparity
        
        dt=0.001;
        
        %number of pixels
        Nx=200;
        Ny=200;
        
        deg_per_pixel=0.025;
        
        subunits=struct();
        
        temporal_kernel='none';

        silent = 0;
        
    end
    
    properties (Hidden, SetAccess=private)
        x;                
        y;
        t;
        n_subunits=0;
        
        init=true;
        
        bootstrap_dir;
        bootstrap_loaded=false;
        toolbox_dir;
        
    end
    
    properties (Hidden)
        memory_threshold=5e9; % in bytes; currently 5GB.
    end
    
    methods
        % These methods are defined in separate files
        bem = add_subunit(bem,varargin);
        bem = modify_subunit(bem,k_sub,varargin);
        bem = update(bem);
        [bem,big_bem] = load_bootstrap(bem,generator);
        
        C = simulate_spatial(bem,generator,n_frames,bootstrap_mode);
        C = simulate_spatiotemporal(bem,generator,n_frames,duration,bootstrap_mode);
        
        
    end
    
    methods
        
        % Constructor
        function bem = BEMunit(varargin)
            % Loop over and set the field to the appropriate value if the
            % field is valid; throw an assertion error otherwise.
            for j = 1:2:(length(varargin)-1);
                assert(isprop(bem,varargin{j}),'Error: Invalid field given to BEM constructor');
                bem.(varargin{j}) = varargin{j+1};
            end
        
            
            % it 'init' is set to false, don't initialise to a standard BEM
            % unit. Default is to initialise a standard BEM unit.
            if bem.init
                
                bem = add_subunit(bem);
                bem = add_subunit(bem,'L_phi',pi/2,'R_phi',pi/2);
                
            end

            % Get the full path of the BEMtoolbox
            BEMunit_dir = mfilename('fullpath');
            stop_idx = strfind(BEMunit_dir,'@BEMunit')-2;
            bem.toolbox_dir=BEMunit_dir(1:stop_idx);
            
            % This is where we save the data
            bem.bootstrap_dir=[bem.toolbox_dir,'/.data/'];            
            
        end
        
       
        
        function display_model(bem,plot_kernels)
            if nargin ==1
                plot_kernels = 0;
            end
            switch bem.dim
                case '2d'
                
                figure(); colormap('gray')
                
                % ticks for the axes
                xtk = linspace(min(bem.x),max(bem.x),5);
                ytk = linspace(min(bem.y),max(bem.y),5);
                clims = zeros(2*bem.n_subunits,2);
                
                for j = 1:bem.n_subunits;
                    subplot(bem.n_subunits,2,(j-1)*2+1);
                    imagesc(bem.x,bem.y,bem.subunits(j).L);
                    title(sprintf('Subunit %i: Left eye',j),'fontsize',14);
                    if j == 2;
                        xlabel('Horizontal position (deg)');
                    end
                    ylabel('Vertical position (deg)');
                    set(gca,'xtick',xtk,'ytick',ytk);
                    clims((j-1)*2+1,:)=get(gca,'clim');

                    subplot(bem.n_subunits,2,j*2)
                    imagesc(bem.x,bem.y,bem.subunits(j).R);
                    title(sprintf('Subunit %i: Right eye',j),'fontsize',14);
                    
                    if j == 2;
                        xlabel('Horizontal position (deg)');
                    end
                    
                    ylabel('Vertical position (deg)');
                    set(gca,'xtick',xtk,'ytick',ytk);
                end
                
                
                for j = 1:(bem.n_subunits*2);
                    subplot(bem.n_subunits,2,j);
                    set(gca,'clim',[min(clims(:)),max(clims(:))]);
                end
                
                if plot_kernels
                    figure();
                    subplot(2,1,1); hold on;
                    for j = 1:bem.n_subunits;
                        [cc_idx,ccf] = get_ccf(bem,j);
                        xdx=cc_idx*bem.deg_per_pixel; xdx=xdx-median(xdx);

                        plot(xdx,ccf,'linewidth',3);
                        xlabel('Disparity (deg)','fontsize',14)
                        ylabel('Responses','fontsize',14);

                    end

                    subplot(2,1,2);
                    for j = 1:bem.n_subunits;
                        % Do something

                    end
                end
                case '1d'
                    % Plot 1d RF shere...
            end
        end
        

        
        
        
        
        function bem = rescale(bem,scale)
            
            for j = 1:length(bem.subunits);
                
                bem.subunits(j).rf_params.left.sx=bem.subunits(j).rf_params.left.sx*scale;
                bem.subunits(j).rf_params.left.sy=bem.subunits(j).rf_params.left.sy*scale;
                bem.subunits(j).rf_params.left.f=bem.subunits(j).rf_params.left.f/scale;
                
                bem.subunits(j).rf_params.right.sx=bem.subunits(j).rf_params.right.sx*scale;
                bem.subunits(j).rf_params.right.sy=bem.subunits(j).rf_params.right.sy*scale;
                bem.subunits(j).rf_params.right.f=bem.subunits(j).rf_params.right.f/scale;
                
            end
            bem = bem.update();
        end
        
        function [cc_dx,ccf] = get_ccf(bem,k_sub)
            % Get cross-correlation function of the kth subunit.
            % Usage: ccf = bem.get_ccf(k);
            % k: index of subunit
            % Returns the cross-sectional cross-correlation function of 
            % the left and right receptive field.
            
            L = bem.subunits(k_sub).L;
            R = bem.subunits(k_sub).R;
            [~,max_idx] = max(var(L,[],1));

            % cross section of left and right RF
            xL = L(max_idx,:);
            xR = R(max_idx,:);

            % cross-correlation function
            ccf=conv(xL(end:-1:1),xR);
            cc_idx=round(length(xL)/2+1):round(length(xL)*1.5);
            cc_dx = (cc_idx-median(cc_idx))*bem.deg_per_pixel;
            ccf = ccf(cc_idx);
        end
        

            
    end
    
   
    methods (Static)
       function rf_params = default_rf_params(~)
            % Usage: rf_params = default_rf_params();
            % Returns a struct with default rf parameters as fields

            %monocular (spatial) properties of receptive field
            rf_params_both.rf_type='gabor';
            %spatial extent of rf
            rf_params_both.sx=0.1;
            rf_params_both.sy=0.1;
            rf_params.sigma=[];
            %frequency of gabor
            rf_params_both.f=0.3./0.1;
            rf_params_both.phi=0;

            % temporal properties of receptive field
            rf_params_both.temporal_kernel='gamma-cosine';
            rf_params_both.tau=0.015;
            rf_params_both.omega=8.3;
            rf_params_both.t_phi=-pi/5;
            rf_params_both.alpha=2.5;
            

            % binocular properties
            rf_params.dphi=0; %phase disparity
            rf_params.dx=0; %position disparity (horizontal)
            rf_params.dy=0; %position disparity (vertical)

            rf_params.left=rf_params_both;
            rf_params.right=rf_params_both;
       end
    end
    
    methods (Access=private)
        function bem = set_centers(bem)
            x_max = bem.Nx * bem.deg_per_pixel;
            y_max = bem.Ny * bem.deg_per_pixel;
            
            if isempty(bem.x0);
                bem.x0 = (rand-0.5)*0.1*x_max;
            end
            if isempty(bem.y0);
                bem.y0 = (rand-0.5)*0.1*y_max;
            end

            x0_L = bem.x0 - bem.dx/2;
            x0_R = bem.x0 + bem.dx/2;

            y0_L = bem.y0 - bem.dy/2;
            y0_R = bem.y0 + bem.dy/2;
            
            for j = 1:length(bem.subunits);
                bem.subunits(j).rf_params.left.x0 = x0_L;
                bem.subunits(j).rf_params.right.x0 = x0_R;
                
                bem.subunits(j).rf_params.left.y0 = y0_L;
                bem.subunits(j).rf_params.right.y0 = y0_R;
            end
            
        end
        
                
        
        
        function save_bootstrap(bem,generator)
            % Saves the computed monocular responses (pre-temporal
            % filtering) to a file with a unique identifier for this model
            % + stimulus. Will extend the file if it already exists.,
            % Usage: bem.save_bootstrap(generator);
            % generator: a stimulus generator object
            
            bem_id = bem.get_identifier();
            stim_id = generator.get_identifier();
            
            % unique ID for bem + stim pairing
            idx_name = [num2str(bem_id),'.idx'];
            mat_name = [num2str(bem_id),'.mat'];
            
            idx_file = [bem.bootstrap_dir,'/',idx_name];
            mat_file = [bem.bootstrap_dir,'/',mat_name];
            
            
            % If there already exists a bem_index file then we want to append
            % it with the stim_id (but only if it doesn't already exist).
            % If it already exists then we shouldn't do anything.            
            if exist(idx_file,'file');
                fid = fopen(idx_file,'r');
                stim_index = textscan(fid,'%s'); 
                stim_index = stim_index{1};
                stim_match = strcmp(stim_index,num2str(stim_id));
                if ~any(stim_match);
                    stim_index{length(stim_index)+1} = num2str(stim_id);
                end
            else
                stim_index = {num2str(stim_id)};
            end                        
                
            
            existing_bootstrap_file = bem.check_bootstrap(generator);
            % If there is an existing bootstrap file then we want to extend
            % it rather than override it.
            if existing_bootstrap_file
                
                fprintf('Found file
                A = load(mat_file); big_bem = A.big_bem;
                bstrap_bem = big_bem.(id2string(stim_id)).bem;
                
                % merge the bstrap_bem and our current bem
                for k = 1:bem.n_subunits
                    current_bem_id = get_identifier(bem,k);
                    match = 0;
                    for j = 1:length(bstrap_bem.subunits);
                        bstrap_id = get_identifier(bstrap_bem,j);
                        if bstrap_id == current_bem_id;
                            match = j;
                        end

                    end

                    assert(match > 0,'No matching subunit found. This is likely a bug.');

                    V_L = bem.subunits(k).V_L;
                    V_R = bem.subunits(k).V_R;

                    bstrap_bem.subunits(match).V_L = [bstrap_bem.subunits(match).V_L,V_L];
                    bstrap_bem.subunits(match).V_R = [bstrap_bem.subunits(match).V_R,V_R];                                        
                end
                bem = bstrap_bem;                       
            else            
                big_bem.(id2string(stim_id)).generator = generator;
                big_bem.(id2string(stim_id)).bem = bem;
            end
            fprintf('Saving file... ')
            
            save(mat_file,'big_bem')
            
            fid=fopen(idx_file,'w');
            fprintf(fid,'%s\n',stim_index{:});
            fclose(fid);
            
            fprintf('Done.\n');
            fclose('all');
        end
        
        
        function bool = check_bootstrap(bem,generator);
            % Method to check whether the current model/stimulus
            % combination has already been bootstrapped
            % Returns a 1 if yes, a 0 if no. 
            % Usage: bool = bem.check_bootstrap(generator);
            
            bool = 0;
            
            bem_id = bem.get_identifier();
            stim_id = generator.get_identifier();
            
            % unique ID for bem + stim pairing
            idx_name = [num2str(bem_id),'.idx'];                        
            idx_file = [bem.bootstrap_dir,'/',idx_name];
            
            if exist(idx_file,'file');
                fid = fopen(idx_file,'r');
                stim_index = textscan(fid,'%s'); 
                stim_index = stim_index{1};
                stim_match = strcmp(stim_index,num2str(stim_id));
                
                bool = any(stim_match);
            end                       
            
        end

        
        
        
    end

    methods (Hidden)
        function id = get_identifier(bem,ks)
            % This method will return a unique identifier
            % based on relevant RF properties for bootstrap resampling.            
            % If 'load_bootstrap' is toggled, this identifier will be used 
            % to find spatial responses that correspond to the cell.
            % Usage: id = bem.get_identifier(<ks>)
            % ks: Optional argument. If not provided, the id will be a
            % unique identifier for the entire unit. If provided, the 
            % 
            
            % This is done by adding together the RMS for the left RF,
            % right RF, and the ccf. These should be positionally
            % invariant metrics. We also add the minimum value of
            % each before taking the RMS, so as to make the metric            
            % sensitive to phase information (this is because
            % rms(x)==rms(-x)).
            
            bem_props = {'dim','dx','dy','Nx','Ny','deg_per_pixel'};
            sub_props = {'sx','sy','f','rf_type','phi'};            
            
            all_props = [];
            for prop = 1:length(bem_props);
                current_prop = num2str(bem.(bem_props{prop}));
                all_props = [all_props,current_prop];
            end
            
            if nargin < 2
                ks = 1:bem.n_subunits;
            end               
            
            for j = ks
                
                for prop = 1:length(sub_props)                    left_prop = num2str(bem.subunits(j).rf_params.left.(sub_props{prop}));
                    right_prop = num2str(bem.subunits(j).rf_params.right.(sub_props{prop}));
                                        
                    all_props = [all_props,left_prop,right_prop];
                end
            end

            id = stringhash(all_props);
            
        end
    end
end
