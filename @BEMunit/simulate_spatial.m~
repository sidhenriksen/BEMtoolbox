 function C = simulate_spatial(bem,generator,n_frames,bootstrap_mode,seed_list)
    % Computes the spatial response of a BEMunit object to a sequence of
    % stimuli created the generator object.
    %
    % Usage: C = bem.simulate_spatial(generator,<n_frames>,<bootstrap_mode>,<seed_list>);
    %
    % generator: Stimulus generator object
    %
    % n_frames (optional): number of frames. Default is 1.
    %
    % bootstrap_mode (optional): Whether to save responses to disk to use for
    % resampling (typically used in conjunction with    
    % simulate_spatiotemporal). Default is 0 (off).
    % 
    % seed_list (optional): A list of seeds used before creating the
    % stimuli. This can be useful if you need to recreate an exact stimulus
    % sequence.
    

    if nargin < 3;
        n_frames = 1;
    end
    
    if nargin < 4
        bootstrap_mode = false;
    end

    if nargin < 5;
        seed_list = [];
        run_seeds = 0;
    else
        assert(length(seed_list) > n_frames,...
            'Error: Seed list must be larger than the number of frames')
        run_seeds = 1;
    end
    
    
    total_bytes = bem.Nx * bem.Ny *n_frames * 8;
    if total_bytes > bem.memory_threshold;
        % In order not flood memory, we split this into smaller pieces and
        % recursively call simulate_spatial with n_frames reduced.
        % We then iteratively place those in the response vector C
        % before exiting.
        
        C = zeros(1,n_frames);
        
        if ~bem.silent
            warning(['Dimensionality of stimulus too high; using serialised implementation to conserve memory (this is slower). ', ...
             'You can manually increase the limit by changing bem.memory_threshold property.'])
        end
        
        repeats = ceil(2*total_bytes/bem.memory_threshold);
        new_n_frames = round(n_frames/(2*total_bytes)*bem.memory_threshold);
        for k = 1:repeats;
            
            if k == repeats;
                new_n_frames = n_frames-(k-1)*new_n_frames;
            end
            
            start = (k-1)*new_n_frames + 1;            
            stop = start+new_n_frames-1;
            
            current_C = simulate_spatial(bem,generator,new_n_frames,bootstrap_mode);
                        
            C(start:stop) = current_C;
        end

    else
        S = zeros(bem.n_subunits,n_frames); % subunit responses
        I_Ls = zeros(bem.Nx*bem.Ny,n_frames);
        I_Rs = zeros(bem.Nx*bem.Ny,n_frames);

        for j = 1:n_frames;
            if run_seeds
                rng(seed_list(j));
            end
            [I_L,I_R] = generator.generate();
            I_Ls(:,j) = I_L(:);
            I_Rs(:,j) = I_R(:);
        end    

        for k = 1:bem.n_subunits;
            
            if n_frames > 0
                % compute left and right eye responses
                L = bem.subunits(k).L(:)' * I_Ls;
                R = bem.subunits(k).R(:)' * I_Rs;
            elseif bootstrap_mode
                L = bem.subunits(k).V_L;
                R = bem.subunits(k).V_R;
            else
                error('Error: Number of frames must be greater than 0');
            end

            if bootstrap_mode
                bem.subunits(k).V_L = L;
                bem.subunits(k).V_R = R;
            end
                    
            
            % add L and R, and pass through nonlinearity
            S(k,:) = bem.subunits(k).NL(L+R);                     
        end
        C = sum(S);
    end

    % Add together subunit responses to get final response
    % (complex cell response in the case of an energy model unit)
    
    if bootstrap_mode;
        bem.save_bootstrap(generator);                
    end
end